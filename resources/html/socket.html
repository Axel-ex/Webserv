<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="./css/style.css">
	<link rel="stylesheet" href="./css/navbar.css">
	<link rel="stylesheet" href="./css/banner.css">
	<!-- <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" /> -->

	<!-- <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" /> -->
	<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script> -->
	<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script> -->
	<title>Socket Programming</title>
</head>

<body>
	<div class="banner">
	</div>
	<!-- Side Navigation Bar -->
	<div id="mySidenav" class="sidenav">
		<div style="padding-bottom: 50px;">
			<a id="closebtn" href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
		</div>
		<div class="pages">
			<a href="index.html">Home</a>
			<a href="server_architecture.html">Server Architecture</a>
			<a href="http_protocol.html">Understanding HTTP</a>
			<a href="socket.html">Socket Programming</a>
			<a href="request_handling.html">Request Handling</a>
			<a href="cgi_handler.html">CGI Implementation</a>
			<a href="logging.html">Logging and Monitoring</a>
			<!-- <a href="security.html">Security Considerations</a> -->
			<!-- <a href="performance_optimization.html">Performance Optimization</a> -->
			<!-- <a href="conclusion.html">Conclusion</a> -->
		</div>
	</div>

	<!-- Open Side Nav Button -->
	<span id="openNav" onclick="openNav()" ;>&#9776;</span>

	<!-- Main Content -->
	<div id="main">
		<h1>Socket Programming in C++: Building a Simple Server</h1>

		<p>Socket programming is the foundation of network communication in many low-level applications. This article
			explains the core concepts involved in building a socket server using C++ and POSIX system calls. The server
			listens for incoming client connections, manages multiple clients using <code>poll()</code>, and
			reads/writes data to/from these clients.</p>

		<p>In this guide, we’ll walk through the creation, binding, and usage of sockets in a multi-client scenario.</p>

		<br>
		<hr>
		<br>

		<h2>1. Creating a Socket</h2>

		<p>The first step in socket programming is to create a socket using the <code>socket()</code> system call.
			Sockets are essentially network endpoint that establishes a connection for sending and receiving data
			between programs. The call to <code>socket()</code> returns a file descriptor (FD) that we can use to refer
			to the socket.</p>

		<div class="illustration">
			<pre class="prettyprint">int sockfd = socket(AF_INET, SOCK_STREAM, 0);
if (sockfd &lt; 0)
    throw ServerError("Fail creating socket");
</pre>
		</div>

		<ul>
			<li><strong>AF_INET</strong>: This indicates the use of IPv4. For IPv6, you would use AF_INET6.</li>
			<li><strong>SOCK_STREAM</strong>: This specifies that the socket will be a TCP stream.</li>
			<li><strong>Protocol (0)</strong>: Typically, 0 is used to choose the default protocol for the socket type,
				which is TCP for SOCK_STREAM.</li>
		</ul>

		<h2>2. Binding the Socket to an Address</h2>

		<p>After creating a socket, it must be bound to an IP address and port number using the <code>bind()</code>
			function. This is achieved using the <code>t_sockaddr_in</code> structure which gives the user the ability
			to assign a name (IP and port) to the socket.</p>

		<div class="illustration">
			<pre class="prettyprint">t_sockaddr_in address;
std::memset(&amp;address, 0, sizeof(address));
address.sin_family = AF_INET;
address.sin_addr.s_addr = INADDR_ANY;
address.sin_port = htons(Config::getPorts()[i]);

if (bind(sockfd, (t_sockaddr *)&amp;address, sizeof(address)) &lt; 0)
    throw ServerError("Fail binding the socket");
</pre>
		</div>

		<ul>
			<li><strong>sin_family</strong>: The address family (AF_INET for IPv4).</li>
			<li><strong>sin_addr.s_addr</strong>: The IP address to bind the socket to (INADDR_ANY binds to all
				available interfaces).</li>
			<li><strong>sin_port</strong>: The port number (converted to network byte order using <code>htons()</code>).
			</li>
		</ul>

		<h2>3. Listening for Connections</h2>

		<p>Once the socket is bound, the server listens for incoming connections using the <code>listen()</code> system
			call:</p>

		<div class="illustration">
			<pre class="prettyprint">if (listen(sockfd, MAX_CLIENT) &lt; 0)
    throw ServerError("fail listening for connection");
</pre>
		</div>

		<p>The <code>listen()</code> function marks the socket as a passive socket that will be used to accept incoming
			connection requests. The backlog parameter defines the maximum number of connections that can be waiting to
			be accepted. If the queue is full, new connection attempts may be refused or ignored.</p>

		<h2>4. Polling for Multiple Clients</h2>

		<p>Handling multiple client connections simultaneously is a challenge. This server uses <code>poll()</code> to
			monitor multiple file descriptors (both server sockets and client connections) for incoming data.</p>

		<div class="illustration">
			<pre class="prettyprint">activity = poll(_fds.data(), _fds.size(), 1000);
</pre>
		</div>

		<ul>
			<li><strong>poll()</strong>: Monitors multiple file descriptors for events, such as data to read or new
				incoming connections.</li>
			<li><strong>_fds</strong>: A vector of file descriptors, including both server and client sockets.</li>
			<li><strong>POLLIN</strong>: Event indicating there is data to read on the socket.</li>
		</ul>

		<h2>5. Accepting Incoming Connections</h2>

		<p>When a server socket detects an event (a new connection request), the server calls <code>accept()</code> to
			accept the client connection and create a new file descriptor for that client.</p>

		<div class="illustration">
			<pre class="prettyprint">int newfd = accept(_fds[i].fd, NULL, NULL);
if (newfd &lt; 0 &amp;&amp; !stopFlag)
    throw ServerError("Error accepting connection");

t_pollfd new_pollfd;
new_pollfd.fd = newfd;
new_pollfd.events = POLLIN;
_fds.push_back(new_pollfd);  // Add new client to poll list
</pre>
		</div>

		<ul>
			<li><strong>accept()</strong>: Accepts a connection from a client and returns a new file descriptor that
				refers to the client’s connection.</li>
			<li><strong>new_pollfd</strong>: A pollfd structure for the newly accepted client connection.</li>
			<li><strong>POLLIN</strong>: Event indicating that there is data to read on the new client socket.</li>
		</ul>

		<h2>6. Reading Data from Clients</h2>

		<p>After a client is connected, the server reads data using <code>recv()</code>. This function receives data
			from the specified file descriptor.</p>

		<div class="illustration">
			<pre class="prettyprint">ssize_t n = recv(_fds[fd_index].fd, buffer, buffer_size, 0);
if (n &lt; 0) {
    close(_fds[fd_index].fd);
    _fds.erase(_fds.begin() + fd_index);
    Log::log(ERROR, "reading client request");
}
</pre>
		</div>

		<ul>
			<li><strong>recv()</strong>: Reads data from the client into the buffer. It returns the number of bytes read
				or -1 on failure.</li>
			<li><strong>close()</strong>: If the client disconnects or an error occurs, the socket is closed, and the
				file descriptor is removed from the polling list.</li>
			<li><strong>buffer</strong>: A buffer to store the received data.</li>
			<li><strong>buffer_size</strong>: The size of the buffer.</li>
		</ul>

		<h2>7. Closing Connections</h2>

		<p>After sending the response, the server closes the connection with the client:</p>

		<div class="illustration">
			<pre class="prettyprint">close(_fds[i].fd);
_fds.erase(_fds.begin() + i);
</pre>
		</div>

		<ul>
			<li><strong>close()</strong>: Closes the connection, freeing the file descriptor.</li>
			<li><strong>_fds.erase()</strong>: Removes the client's file descriptor from the polling list.</li>
		</ul>

		<h2>Conclusion</h2>

		<p>In summary, socket programming is a powerful technique for building networked applications. Socket
			programming essentially comes down to:</p>

		<ul>
			<li><strong>Create and configure sockets</strong>: Setting up the basic communication channels using
				<code>socket()</code>, configuring options with <code>setsockopt()</code>, and binding to addresses and
				ports.
			</li>
			<li><strong>Listen for incoming connections</strong>: Using <code>listen()</code> to wait for client
				connection requests.</li>
			<li><strong>Manage multiple clients</strong>: Leveraging <code>poll()</code> to handle multiple file
				descriptors efficiently.</li>
			<li><strong>Accept and handle client connections</strong>: Accepting new connections with
				<code>accept()</code>, reading data with <code>recv()</code>, and responding to clients.
			</li>
			<li><strong>Close connections</strong>: Properly closing and removing file descriptors to manage resources
				effectively.</li>
		</ul>

	</div>

	<!-- JavaScript -->
	<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
	<script src="./js/script.js"></script>
</body>

</html>